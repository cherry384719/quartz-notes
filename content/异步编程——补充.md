# JavaScript异步编程详解 - 定时器与Promise


## 什么是异步编程

### 同步 vs 异步

JavaScript是单线程语言，但通过异步编程可以处理耗时操作而不阻塞主线程。

```javascript
// 同步代码 - 阻塞执行
console.log('1');
console.log('2');
console.log('3');
// 输出: 1, 2, 3 (按顺序)

// 异步代码 - 非阻塞执行
console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3');
// 输出: 1, 3, 2 (异步代码后执行)
```

### 事件循环机制

JavaScript通过事件循环来处理异步操作：

1. **调用栈**: 执行同步代码
2. **Web APIs**: 处理异步操作（如定时器、网络请求）
3. **任务队列**: 存储待执行的回调函数
4. **事件循环**: 将任务队列中的任务移到调用栈

## 定时器详解

### setTimeout - 延时执行

```javascript
// 基本语法
setTimeout(callback, delay, ...args)

// 基本用法
setTimeout(() => {
    console.log('3秒后执行');
}, 3000);

// 传递参数
setTimeout((name, age) => {
    console.log(`姓名: ${name}, 年龄: ${age}`);
}, 1000, '小明', 25);

// 返回定时器ID，可用于清除
const timerId = setTimeout(() => {
    console.log('这不会执行');
}, 5000);
clearTimeout(timerId); // 清除定时器
```

### setInterval - 重复执行

```javascript
// 基本语法
setInterval(callback, interval, ...args)

// 基本用法
const intervalId = setInterval(() => {
    console.log('每2秒执行一次');
}, 2000);

// 5秒后停止
setTimeout(() => {
    clearInterval(intervalId);
    console.log('定时器已停止');
}, 5000);
```

### 定时器的注意事项

```javascript
// 1. 最小延时
setTimeout(() => console.log('立即执行'), 0); // 实际延时约4ms

// 2. this指向问题
const obj = {
    name: '对象',
    sayHello() {
        console.log(`你好, ${this.name}`);
    },
    delayedHello() {
        // 错误方式 - this指向window
        setTimeout(this.sayHello, 1000);
        
        // 正确方式1 - 箭头函数
        setTimeout(() => this.sayHello(), 1000);
        
        // 正确方式2 - bind
        setTimeout(this.sayHello.bind(this), 1000);
    }
};
```

## Promise详解

### Promise基础概念

Promise是处理异步操作的对象，有三种状态：

- **pending**: 待定（初始状态）
- **fulfilled**: 已兑现（操作成功）
- **rejected**: 已拒绝（操作失败）

```javascript
// 创建Promise
const myPromise = new Promise((resolve, reject) => {
    // 异步操作
    const success = Math.random() > 0.5;
    
    setTimeout(() => {
        if (success) {
            resolve('操作成功！'); // 改变状态为fulfilled
        } else {
            reject('操作失败！'); // 改变状态为rejected
        }
    }, 1000);
});

// 使用Promise
myPromise
    .then(result => {
        console.log('成功:', result);
    })
    .catch(error => {
        console.log('失败:', error);
    });
```

### Promise链式调用

```javascript
// 链式调用处理多个异步操作
function getData(id) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (id > 0) {
                resolve({ id, name: `用户${id}` });
            } else {
                reject('无效的ID');
            }
        }, 1000);
    });
}

getData(1)
    .then(user => {
        console.log('获取用户:', user);
        return getData(user.id + 1); // 返回新的Promise
    })
    .then(nextUser => {
        console.log('获取下一个用户:', nextUser);
        return '所有操作完成';
    })
    .then(result => {
        console.log(result);
    })
    .catch(error => {
        console.log('出错了:', error);
    });
```

### Promise静态方法

```javascript
// Promise.resolve() - 创建已解决的Promise
const resolvedPromise = Promise.resolve('立即解决');
resolvedPromise.then(console.log); // 输出: 立即解决

// Promise.reject() - 创建已拒绝的Promise
const rejectedPromise = Promise.reject('立即拒绝');
rejectedPromise.catch(console.log); // 输出: 立即拒绝

// Promise.all() - 等待所有Promise完成
const promise1 = new Promise(resolve => setTimeout(() => resolve('结果1'), 1000));
const promise2 = new Promise(resolve => setTimeout(() => resolve('结果2'), 2000));
const promise3 = new Promise(resolve => setTimeout(() => resolve('结果3'), 1500));

Promise.all([promise1, promise2, promise3])
    .then(results => {
        console.log('所有Promise完成:', results);
        // 输出: ['结果1', '结果2', '结果3']
    })
    .catch(error => {
        console.log('有Promise失败:', error);
    });

// Promise.race() - 等待第一个Promise完成
Promise.race([promise1, promise2, promise3])
    .then(result => {
        console.log('第一个完成:', result); // 输出: 结果1
    });

// Promise.allSettled() - 等待所有Promise完成（不管成功失败）
const mixedPromises = [
    Promise.resolve('成功'),
    Promise.reject('失败'),
    Promise.resolve('也成功')
];

Promise.allSettled(mixedPromises)
    .then(results => {
        console.log('所有结果:', results);
        // 输出包含每个Promise的状态和值/原因
    });
```

### async/await语法

```javascript
// async函数返回Promise
async function fetchData() {
    return '数据';
}

fetchData().then(console.log); // 输出: 数据

// await等待Promise解决
async function processData() {
    try {
        const data1 = await getData(1);
        console.log('第一个数据:', data1);
        
        const data2 = await getData(2);
        console.log('第二个数据:', data2);
        
        return '处理完成';
    } catch (error) {
        console.log('处理出错:', error);
        throw error; // 重新抛出错误
    }
}

// 使用async函数
processData()
    .then(result => console.log(result))
    .catch(error => console.log('最终错误:', error));
```

## 实际应用示例

### 1. 模拟网络请求

```javascript
// 模拟API请求
function apiRequest(url, delay = 1000) {
    return new Promise((resolve, reject) => {
        console.log(`请求开始: ${url}`);
        
        setTimeout(() => {
            const success = Math.random() > 0.2; // 80%成功率
            
            if (success) {
                resolve({
                    status: 200,
                    data: `来自${url}的数据`,
                    timestamp: new Date().toISOString()
                });
            } else {
                reject({
                    status: 500,
                    error: '网络错误'
                });
            }
        }, delay);
    });
}

// 使用示例
async function loadUserData() {
    try {
        const userInfo = await apiRequest('/api/user/123');
        console.log('用户信息:', userInfo);
        
        const userPosts = await apiRequest('/api/posts/user/123');
        console.log('用户文章:', userPosts);
        
        return { userInfo, userPosts };
    } catch (error) {
        console.error('加载失败:', error);
        throw error;
    }
}
```

### 2. 定时器 + Promise 组合

```javascript
// 创建延时Promise
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// 带超时的Promise
function withTimeout(promise, timeoutMs) {
    return Promise.race([
        promise,
        delay(timeoutMs).then(() => {
            throw new Error(`操作超时 (${timeoutMs}ms)`);
        })
    ]);
}

// 使用示例
async function fetchWithTimeout() {
    try {
        const result = await withTimeout(
            apiRequest('/api/data'),
            3000 // 3秒超时
        );
        console.log('获取成功:', result);
    } catch (error) {
        if (error.message.includes('超时')) {
            console.log('请求超时');
        } else {
            console.log('请求失败:', error);
        }
    }
}
```

### 3. 进度跟踪

```javascript
// 带进度的异步操作
function downloadFile(filename, totalSize) {
    return new Promise((resolve, reject) => {
        let downloaded = 0;
        
        const interval = setInterval(() => {
            downloaded += Math.random() * 1000000; // 随机下载速度
            const progress = Math.min(downloaded / totalSize, 1);
            
            console.log(`下载进度: ${(progress * 100).toFixed(1)}%`);
            
            if (progress >= 1) {
                clearInterval(interval);
                resolve(`${filename} 下载完成`);
            }
        }, 100);
        
        // 模拟下载失败
        setTimeout(() => {
            if (Math.random() < 0.1) { // 10%失败率
                clearInterval(interval);
                reject('下载失败');
            }
        }, Math.random() * 2000);
    });
}

// 使用示例
downloadFile('document.pdf', 5000000)
    .then(result => console.log(result))
    .catch(error => console.log('错误:', error));
```

## 常见问题与最佳实践

### 1. 错误处理

```javascript
// 好的错误处理
async function robustAsyncFunction() {
    try {
        const result = await someAsyncOperation();
        return result;
    } catch (error) {
        console.error('操作失败:', error);
        // 记录错误、显示用户友好消息等
        throw new Error('操作失败，请稍后重试');
    }
}

// Promise链中的错误处理
somePromise
    .then(result => processResult(result))
    .catch(error => {
        console.error('处理出错:', error);
        return 'default value'; // 返回默认值继续链式调用
    })
    .then(result => {
        console.log('最终结果:', result);
    });
```

### 2. 避免回调地狱

```javascript
// 不好的嵌套回调
getData(1, (user) => {
    getUser(user.id, (profile) => {
        getPosts(profile.id, (posts) => {
            console.log(posts);
        });
    });
});

// 使用Promise链
getData(1)
    .then(user => getUser(user.id))
    .then(profile => getPosts(profile.id))
    .then(posts => console.log(posts))
    .catch(error => console.error(error));

// 使用async/await
async function loadData() {
    try {
        const user = await getData(1);
        const profile = await getUser(user.id);
        const posts = await getPosts(profile.id);
        console.log(posts);
    } catch (error) {
        console.error(error);
    }
}
```

### 3. 并发控制

```javascript
// 并行执行多个独立的异步操作
async function loadAllData() {
    const [users, posts, comments] = await Promise.all([
        getUsers(),
        getPosts(),
        getComments()
    ]);
    
    return { users, posts, comments };
}

// 限制并发数量
async function processItemsWithLimit(items, processor, limit = 3) {
    const results = [];
    
    for (let i = 0; i < items.length; i += limit) {
        const batch = items.slice(i, i + limit);
        const batchResults = await Promise.all(
            batch.map(item => processor(item))
        );
        results.push(...batchResults);
    }
    
    return results;
}
```

### 4. 内存泄漏防护

```javascript
// 清理定时器防止内存泄漏
class Timer {
    constructor() {
        this.timers = new Set();
    }
    
    setTimeout(callback, delay) {
        const id = setTimeout(() => {
            callback();
            this.timers.delete(id);
        }, delay);
        this.timers.add(id);
        return id;
    }
    
    clearAll() {
        this.timers.forEach(id => clearTimeout(id));
        this.timers.clear();
    }
}

// 组件卸载时清理
const timer = new Timer();
// 使用timer.setTimeout代替全局setTimeout
// 组件卸载时调用timer.clearAll()
```

## 总结

JavaScript异步编程的核心概念：

1. **定时器**: 用于延时和重复执行，注意清理防止内存泄漏
2. **Promise**: 处理异步操作的标准方式，支持链式调用
3. **async/await**: 让异步代码看起来像同步代码，更易读易维护
4. **错误处理**: 使用try/catch和.catch()确保程序稳定性
5. **并发控制**: 合理使用Promise.all()等方法提高性能

掌握这些概念和技巧，你就能够熟练地处理JavaScript中的各种异步场景了！